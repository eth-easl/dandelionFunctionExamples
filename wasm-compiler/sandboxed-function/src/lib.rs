#![no_std]
/// This is a wrapper around the transpiled Rust code generated by rWasm.
/// It exposes the necessary entrypoints for Dandelion.
/// The primary reason for the existance of this wrapper is the
///     #[no_mangle]
/// requirement for exposed symbols, which does not work with the
///    #![forbid(unsafe_code)]
/// requirement in the rWasm generated code.

// need to define a panic handler, since this is a cdylib
use core::panic::PanicInfo;
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[macro_use]
extern crate macro_utils;
#[no_mangle]
pub static SYSTEM_DATA_WASM_MEM_OFFSET: i32 = macro_utils::get_system_data_wasm_offset!();
// TODO: if we ever link this against other binaries, LLVM might still mangle 
//       symbols. In case consider:
//       https://github.com/rust-lang/rust/issues/35052#issuecomment-235420755

mod DandelionInterface {
    pub struct io_set_info {
        ident: *const u8,   // const char*
        ident_len: usize,
        offset: usize,
    }

    pub struct io_buffer {
        ident: *const u8,   // const char*
        ident_len: usize,
        data: *mut u8,      // void*
        data_len: usize,
        key: usize,
    }

    pub struct SystemData {
        exit_code: i32,
        heap_begin: usize,
        heap_end: usize,
        input_sets_len: usize,
        input_sets: *mut io_set_info,
        output_sets_len: usize,
        output_sets: *mut io_set_info,
        input_bufs: *mut io_buffer,
        output_bufs: *mut io_buffer,
    }

    extern "C" {
        pub static mut SYSTEM_DATA_PTR: *mut SystemData;
    }
}

mod wrapper {
    extern crate sandbox_generated;
    use sandbox_generated as Generated;

    pub struct __WasmModule {
        pub module: Generated::WasmModule,
    }

    impl __WasmModule {
        #[no_mangle]
        pub fn new() -> Self {
            Self {
                module: Generated::WasmModule::new(),
            }
        }
        #[no_mangle]
        #[allow(non_snake_case)]
        pub fn get___system_data(&self) -> Option<i32> {
            self.module.get___dandelion_system_data()
        }
        #[no_mangle]
        #[allow(non_snake_case)]
        pub fn alloc(&mut self, size: i32, alignment: i32) -> i32 {
            self.module.dandelion_alloc(size, alignment).unwrap()
        }
    }
}

#[no_mangle]
pub unsafe fn _start() -> i32 {
    let mut module = wrapper::__WasmModule::new();
    // check that we received system data from the host
    match DandelionInterface::SYSTEM_DATA_PTR as i32 {
        0 => return -2,
        _ => ()
    };
    // write system data to the wasm module's memory
    // TODO
    match module.module._start() {
        Some(_) => 0,
        None => -1,
    }
}