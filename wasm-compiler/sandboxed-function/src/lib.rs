#![no_std]
/// This is a wrapper around the transpiled Rust code generated by rWasm.
/// It exposes the necessary entrypoints for Dandelion.
/// The primary reason for the existance of this wrapper is the
///     #[no_mangle]
/// requirement for exposed symbols, which does not work with the
///    #![forbid(unsafe_code)]
/// requirement in the rWasm generated code.

// need to define a panic handler, since this is a cdylib
use core::panic::PanicInfo;
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

extern crate macro_utils;
#[no_mangle]
pub static SYSTEM_DATA_WASM_MEM_OFFSET: i32 = macro_utils::get___dandelion_system_data!();
#[no_mangle]
pub static INTERFACE_MEM_SIZE_FOR_WASM: i32 = macro_utils::get_INTERFACE_MEM_SIZE_FOR_WASM!();
#[no_mangle]
pub static INTERFACE_MEM_FOR_WASM: i32 = macro_utils::get_INTERFACE_MEM_FOR_WASM!();

mod function_interface {

    use libc::{c_int, size_t, uintptr_t};

    #[repr(C)]
    pub struct DandelionSystemData {
        exit_code: c_int,
        heap_begin: uintptr_t,
        heap_end: uintptr_t,
        input_sets_len: size_t,
        input_sets: *const IoSetInfo,
        output_sets_len: size_t,
        output_sets: *const IoSetInfo,
        input_bufs: *const IoBufferDescriptor,
        output_bufs: *const IoBufferDescriptor,
    }

    #[repr(C)]
    pub struct IoSetInfo {
        ident: uintptr_t,
        ident_len: size_t,
        offset: size_t,
    }

    #[repr(C)]
    pub struct IoBufferDescriptor {
        ident: uintptr_t,
        ident_len: size_t,
        data: uintptr_t,
        data_len: size_t,
        key: size_t,
    }

    #[no_mangle]
    // a pointer to a pointer to a DandelionSystemData struct.
    // this makes it easy for Dandelion to just modify the pointer
    // in memory that this points to, and make it point to the
    // DandelionSystemData struct in the runtime, without copying.
    pub static SYSTEM_DATA_PTR_PTR: &usize = &0;
}

mod wrapper {
    extern crate sandbox_generated;
    use sandbox_generated as Generated;

    pub struct WasmModule(pub Generated::WasmModule);

    impl WasmModule {
        #[no_mangle]
        pub fn new() -> Self {
            Self (Generated::WasmModule::new())
        }
        #[no_mangle]
        #[allow(non_snake_case)]
        pub fn get___system_data(&self) -> Option<i32> {
            self.0.get___dandelion_system_data()
        }
        #[no_mangle]
        #[allow(non_snake_case)]
        pub fn alloc(&mut self, size: i32, alignment: i32) -> i32 {
            self.0.dandelion_alloc(size, alignment).unwrap()
        }
    }
}

#[no_mangle]
pub unsafe fn _start() -> i32 {
    let mut module = wrapper::WasmModule::new();

    let system_data_ptr = *function_interface::SYSTEM_DATA_PTR_PTR 
        as *const function_interface::DandelionSystemData;
    let _system_data = &*system_data_ptr;

    // now we can also set up input and output structs here
    // which we cannot easily do from Dandelion, because
    // we don't know yet where module::memory will be located
    // TODO
    match module.0._start() {
        Some(_) => 0,
        None => -1,
    }
}