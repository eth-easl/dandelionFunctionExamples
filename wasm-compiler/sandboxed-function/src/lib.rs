#![no_std]
/// This is a wrapper around the transpiled Rust code generated by rWasm.
/// It exposes the necessary entrypoints for Dandelion.
/// The primary reason for the existance of this wrapper is the
///     #[no_mangle]
/// requirement for exposed symbols, which does not work with the
///    #![forbid(unsafe_code)]
/// requirement in the rWasm generated code.

// need to define a panic handler, since this is a cdylib

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

// convenience macros to extract some data for Dandelion from the generated code

// #[macro_use]
// extern crate macro_utils;

// TODO: when linking this crate with other libraries, LLVM might still
//       mangle symbols. In case this might happen, see how to prevent it here:
//       https://github.com/rust-lang/rust/issues/35052#issuecomment-235420755
#[no_mangle]
pub static SYSTEM_DATA_PTR: i32 = 0;// macro_utils::get_system_data!();

// the actual wrapper

extern crate sandbox_generated;
use sandbox_generated as Generated;


struct __WasmModule {
    module: Generated::WasmModule,
}

impl __WasmModule {
    #[no_mangle]
    pub fn new() -> Self {
        Self {
            module: Generated::WasmModule::new(),
        }
    }
    #[no_mangle]
    #[allow(non_snake_case)]
    pub fn get___system_data(&self) -> Option<i32> {
        self.module.get___dandelion_system_data()
    }
    #[no_mangle]
    #[allow(non_snake_case)]
    pub fn alloc(&mut self, size: i32, alignment: i32) -> i32 {
        self.module.dandelion_alloc(size, alignment).unwrap()
    }
}

#[no_mangle]
pub fn _start() {
    let mut module = __WasmModule::new();
    module.module._start();
}