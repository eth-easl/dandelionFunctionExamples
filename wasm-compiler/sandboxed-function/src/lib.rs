#![cfg_attr(not(test), no_std)]
/// This is a wrapper around the transpiled Rust code generated by rWasm.
/// It exposes the necessary entrypoints for Dandelion.
/// The primary reason for the existance of this wrapper is the
///     #[no_mangle]
/// requirement for exposed symbols, which does not work with the
///    #![forbid(unsafe_code)]
/// requirement in the rWasm generated code.

// need to define a panic handler, since this is a cdylib
use core::panic::PanicInfo;
#[cfg_attr(not(test), panic_handler)]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[no_mangle]
pub static mut INSTANCE: wrapper::WasmModule = wrapper::WasmModule::new();
#[no_mangle]
pub static SYSDATA_MEM_START_IDX: usize = unsafe { 
    match INSTANCE.0.get_INTERFACE_MEM_FOR_WASM() {
        Some(x) => x as usize,
        None => panic!("cannot read SYSDATA_MEM_START"),
    
    }
};
#[no_mangle]
pub static SYSDATA_MEM_SIZE: usize = unsafe { 
    match INSTANCE.0.get_INTERFACE_MEM_SIZE_FOR_WASM() {
        Some(x) => x as usize,
        None => panic!("cannot read SYSDATA_MEM_SIZE"),
    }
};
#[no_mangle]
pub static SYSTEM_DATA_IDX: usize = unsafe { 
    match INSTANCE.0.get___dandelion_system_data() {
        Some(x) => x as usize,
        None => panic!("cannot read SYSTEM_DATA_IDX"),
    }
};

mod wrapper {
    extern crate sandbox_generated;

    pub struct WasmModule(pub sandbox_generated::WasmModule);

    impl WasmModule {
        #[no_mangle]
        pub const fn new() -> Self {
            Self (sandbox_generated::WasmModule::new())
        }
        #[no_mangle]
        pub fn run(&mut self) -> Option<()> {
            self.0._start()
        }
    }
}

#[no_mangle]
pub fn _start() {
    unsafe { INSTANCE.run(); }
}

#[no_mangle]
pub fn _sanity_check() -> i32 { 42 }
